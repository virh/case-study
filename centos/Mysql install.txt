#mysql server
yum localinstall mysql57-community-release-el7-11.noarch.rpm
yum repolist enabled | grep "mysql.-community."
#vim /etc/yum.repos.d/mysql-community.repo
yum install mysql-community-server
systemctl start mysqld
systemctl status mysqld
# start reboot
systemctl enable mysqld 
systemctl daemon-reload

grep 'temporary password' /var/log/mysqld.log
#replace rnu7=jSy6w8a by /var/log/mysqld.log tip root@localhost:%s
mysql -uroot -p
set global validate_password_policy=0;
ALTER USER 'root'@'localhost' IDENTIFIED BY 'rootroot';

#mysql shell
yum install mysql-shell

#mysql router
yum install mysql-router

#install X plugin
mysqlsh -u root -h localhost -p --classic --dba enableXProtocol

# mysql config file location
/etc/my.cnf»ò/usr/share/mysql/my.cnf

# setting master configuration
[mysqld]
log-bin=mysql-bin
server-id=1

# setting replication slave configuration
[mysqld]
server-id=2

# on master db
mysql> set global validate_password_policy=0;
mysql> CREATE USER 'rep1'@'%' IDENTIFIED BY 'password';
mysql> GRANT REPLICATION SLAVE ON *.* TO 'rep1'@'%';

# block write statements
mysql> FLUSH TABLES WITH READ LOCK;
mysql > SHOW MASTER STATUS;

#copy data
shell> mysqldump --all-databases --master-data > dbdump.db

#import data
mysql -p<dbdump.db;

#copy data using raw data files
shell> mysqladmin shutdown
shell> tar cfP /tmp/db.tar /var/lib/mysql
shell> zip -r /tmp/db.zip /var/lib/mysql
shell> rsync --recursive /var/lib/mysql /tmp/dbdata

# release table lock
mysql> UNLOCK TABLES;

# setting the master configuration on the slave
# rep1 & rep2
mysql> CHANGE MASTER TO MASTER_HOST='192.168.238.130',MASTER_USER='rep1',MASTER_PASSWORD='password',MASTER_LOG_FILE='mysql-bin.000003',MASTER_LOG_POS=154;
STOP SLAVE; -- if replication was running
CHANGE MASTER TO MASTER_PASSWORD='new3cret';
START SLAVE; -- if you want to restart replication

# create test table
create table testdb (id bigint not null, primary key(id)) engine=innodb;

# drop test table
drop table testdb;



# replication
This brings us to rule number one ¨C if you care about replication latency you must not have any long running updates. Queries or transactions containing multiple update queries which add up to long time. I would keep the maximum query length at about 1/5th of the maximum replication lag you¡¯re ready to tolerate. So if you want your replica to be no more than 1 minute behind keep the longest update query to 10 sec or so. This is of course rule of thumb depending on differences in master/slave configuration, their load and concurrency you may need to keep the ratio higher or allow a bit longer queries.

# execute after delete user
REVOKE ALL PRIVILEGES,GRANT OPTION FROM orchestrator;
flush privileges; 


# special db replication
STOP SLAVE SQL_THREAD;
CHANGE REPLICATION FILTER REPLICATE_DO_DB=(db1);
START SLAVE SQL_THREAD;

# show table status 
# show tables [from db]
# show columns from [db.]table

# insert into mytest;
insert into testdb(id) values ('1');
# insert into mytest2;
insert into testdb2(id) values ('1');


# update mysql password
update mysql.user set authentication_string=password('orch_topology_password');

# create application user
CREATE USER 'app'@'%' IDENTIFIED BY 'password';
GRANT ALL PRIVILEGES ON mytest.* TO 'app'@'%';
GRANT ALL PRIVILEGES ON mytest2.* TO 'app'@'%';
FLUSH PRIVILEGES;


# readonly
SET GLOBAL read_only=ON;
select @@global.read_only; //1 @@global.super_read_only
select @@global.log_slave_updates;
# log slave updates
[mysqld]
log-slave-updates=true

select @@global.log_slave_updates;

show global variables like '%slave%';

# show binlog events
show binlog events 'mysql-bin.000004' from 154;

gtid-mode=ON to my.cnf


# orchestrator
orchestrator -c which-cluster -i some.instance.in.cluster

#
orchestrator -c which-replicas -i $master | shuf | head -1